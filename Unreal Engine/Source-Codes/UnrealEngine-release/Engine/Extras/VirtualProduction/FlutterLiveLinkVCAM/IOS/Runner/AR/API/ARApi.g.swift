// Copyright Epic Games, Inc. All Rights Reserved.
// 
// This is an auto-generated file. See FlutterLiveLinkVCAM/pigeons/README for information on how to
// modify the original source and generate a new file.
// 
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Possible tracking states for an AR session's camera.
enum ArTrackingState: Int {
  /// Tracking data is available.
  case normal = 0
  /// Tracking data may not be accurate.
  case limited = 1
  /// Tracking data is unavailable.
  case unavailable = 2
}

/// Availability of AR features on the device.
enum ArAvailability: Int {
  /// The feature is not available on the user's device.
  case notSupported = 0
  /// The feature may be available on the user's device, but the user declined to install or encountered an error while
  /// doing so.
  case notInstalled = 1
  /// The feature may be available on the user's device, but the user declined camera permission.
  case cameraNotPermitted = 2
  /// The feature is ready to use.
  case available = 3
}

/// Data produced during a single frame in an AR session.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ArFrame {
  /// Data for the camera's 4x4 transform matrix.
  var cameraTransformData: FlutterStandardTypedData

  static func fromList(_ list: [Any?]) -> ArFrame? {
    let cameraTransformData = list[0] as! FlutterStandardTypedData

    return ArFrame(
      cameraTransformData: cameraTransformData
    )
  }
  func toList() -> [Any?] {
    return [
      cameraTransformData,
    ]
  }
}

/// API that receives messages about ArSession instances in the host language.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ArSessionHostApi {
  /// Request all necessary permissions and/or installation steps for AR functionality.
  /// Must be called before [create].
  /// Completes with the new availability after user agreement completes or fails.
  /// If the platform doesn't require this step, the future completes immediately.
  func initialize(completion: @escaping (Result<ArAvailability, Error>) -> Void)
  /// Create an AR session.
  /// Returns an ID which can be used to refer to the native object in future calls.
  func create(completion: @escaping (Result<Int64, Error>) -> Void)
  /// Dispose of the AR session with the given [sessionId].
  func dispose(sessionId: Int64) throws
  /// Run the AR session with the given [sessionId].
  /// It will begin firing delegate events every frame.
  func run(sessionId: Int64) throws
  /// Pause the AR session with the given [sessionId].
  /// It will stop processing until [run] is called again.
  func pause(sessionId: Int64) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ArSessionHostApiSetup {
  /// The codec used by ArSessionHostApi.
  /// Sets up an instance of `ArSessionHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ArSessionHostApi?) {
    /// Request all necessary permissions and/or installation steps for AR functionality.
    /// Must be called before [create].
    /// Completes with the new availability after user agreement completes or fails.
    /// If the platform doesn't require this step, the future completes immediately.
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.ArSessionHostApi.initialize", binaryMessenger: binaryMessenger)
    if let api = api {
      initializeChannel.setMessageHandler { _, reply in
        api.initialize() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res.rawValue))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    /// Create an AR session.
    /// Returns an ID which can be used to refer to the native object in future calls.
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.ArSessionHostApi.create", binaryMessenger: binaryMessenger)
    if let api = api {
      createChannel.setMessageHandler { _, reply in
        api.create() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    /// Dispose of the AR session with the given [sessionId].
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.ArSessionHostApi.dispose", binaryMessenger: binaryMessenger)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sessionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.dispose(sessionId: sessionIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    /// Run the AR session with the given [sessionId].
    /// It will begin firing delegate events every frame.
    let runChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.ArSessionHostApi.run", binaryMessenger: binaryMessenger)
    if let api = api {
      runChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sessionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.run(sessionId: sessionIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      runChannel.setMessageHandler(nil)
    }
    /// Pause the AR session with the given [sessionId].
    /// It will stop processing until [run] is called again.
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.ArSessionHostApi.pause", binaryMessenger: binaryMessenger)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sessionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.pause(sessionId: sessionIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
  }
}
private class ArSessionFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return ArFrame.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class ArSessionFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? ArFrame {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class ArSessionFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ArSessionFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ArSessionFlutterApiCodecWriter(data: data)
  }
}

class ArSessionFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = ArSessionFlutterApiCodec(readerWriter: ArSessionFlutterApiCodecReaderWriter())
}

/// API that receives messages about ArSession instances in Flutter.
///
/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class ArSessionFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return ArSessionFlutterApiCodec.shared
  }
  /// Called when the AR session with the given [sessionId] produces data for a new [frame].
  func onFrame(sessionId sessionIdArg: Int64, frame frameArg: ArFrame, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.ArSessionFlutterApi.onFrame", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([sessionIdArg, frameArg] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when the camera tracking [state] for AR session with the given [sessionId] changes.
  func onTrackingStateChanged(sessionId sessionIdArg: Int64, state stateArg: ArTrackingState, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.ArSessionFlutterApi.onTrackingStateChanged", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([sessionIdArg, stateArg.rawValue] as [Any?]) { _ in
      completion()
    }
  }
}
