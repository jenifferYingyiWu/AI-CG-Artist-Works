// Copyright Epic Games, Inc. All Rights Reserved.
// 
// This is an auto-generated file. See FlutterLiveLinkVCAM/pigeons/README for information on how to
// modify the original source and generate a new file.
// 
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Supported types for [RtcSessionDescription].
enum RtcSessionDescriptionType: Int {
  case answer = 0
  case offer = 1
  case pranswer = 2
  case rollback = 3
}

/// State of an [RtcPeerConnection]'s connection to the corresponding peer.
enum RtcPeerConnectionState: Int {
  case newConnection = 0
  case connecting = 1
  case connected = 2
  case disconnected = 3
  case failed = 4
  case closed = 5
}

/// Kinds of MediaStreamTrack that can be created.
enum RtcMediaStreamTrackKind: Int {
  case audio = 0
  case video = 1
}

/// State of an [RtcDataChannel].
enum RtcDataChannelState: Int {
  case connecting = 0
  case open = 1
  case closing = 2
  case closed = 3
}

/// A buffer passed from/to WebRTC, which may contain either binary or text data.
///
/// Generated class from Pigeon that represents data sent in messages.
struct RtcDataBuffer {
  /// The binary data contained in the buffer.
  var data: FlutterStandardTypedData
  /// True if the buffer contains binary data; otherwise, it contains UTF-8 text.
  var bIsBinary: Bool

  static func fromList(_ list: [Any?]) -> RtcDataBuffer? {
    let data = list[0] as! FlutterStandardTypedData
    let bIsBinary = list[1] as! Bool

    return RtcDataBuffer(
      data: data,
      bIsBinary: bIsBinary
    )
  }
  func toList() -> [Any?] {
    return [
      data,
      bIsBinary,
    ]
  }
}

/// Describes the configuration of one end of a peer-to-peer WebRtc connection.
///
/// Generated class from Pigeon that represents data sent in messages.
struct RtcSessionDescription {
  /// The type of description.
  var type: RtcSessionDescriptionType
  /// The SDP information describing the session.
  var sdp: String

  static func fromList(_ list: [Any?]) -> RtcSessionDescription? {
    let type = RtcSessionDescriptionType(rawValue: list[0] as! Int)!
    let sdp = list[1] as! String

    return RtcSessionDescription(
      type: type,
      sdp: sdp
    )
  }
  func toList() -> [Any?] {
    return [
      type.rawValue,
      sdp,
    ]
  }
}

/// A candidate for interactive connectivity establishment (ICE) to a peer.
///
/// Generated class from Pigeon that represents data sent in messages.
struct RtcIceCandidate {
  /// A string describing the candidate (taken from the SDP "candidate" field).
  var candidate: String
  /// A string specifying the candidate's unique media stream ID tag.
  var sdpMid: String
  /// The index number of the media description within the SDP.
  var sdpMLineIndex: Int64

  static func fromList(_ list: [Any?]) -> RtcIceCandidate? {
    let candidate = list[0] as! String
    let sdpMid = list[1] as! String
    let sdpMLineIndex = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)

    return RtcIceCandidate(
      candidate: candidate,
      sdpMid: sdpMid,
      sdpMLineIndex: sdpMLineIndex
    )
  }
  func toList() -> [Any?] {
    return [
      candidate,
      sdpMid,
      sdpMLineIndex,
    ]
  }
}

/// Event data for when a track is added to a stream in a [RtcPeerConnection].
///
/// Generated class from Pigeon that represents data sent in messages.
struct RtcTrackEvent {
  /// The unique ID of the media track used to refer to it when communicating with the native plugin.
  var trackId: Int64
  /// The kind of media in this track.
  var kind: RtcMediaStreamTrackKind

  static func fromList(_ list: [Any?]) -> RtcTrackEvent? {
    let trackId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let kind = RtcMediaStreamTrackKind(rawValue: list[1] as! Int)!

    return RtcTrackEvent(
      trackId: trackId,
      kind: kind
    )
  }
  func toList() -> [Any?] {
    return [
      trackId,
      kind.rawValue,
    ]
  }
}

/// Reported statistics about a single object inspected as part of a WebRTC report.
///
/// Generated class from Pigeon that represents data sent in messages.
struct RtcStats {
  /// Timestamp at which the stats were gathered (in microseconds).
  var timestampUs: Double
  /// The type of object for which these stats were collected.
  var type: String
  /// The unique ID of the stats object.
  var id: String
  /// Map from stat name to its value.
  var values: [String?: Any?]

  static func fromList(_ list: [Any?]) -> RtcStats? {
    let timestampUs = list[0] as! Double
    let type = list[1] as! String
    let id = list[2] as! String
    let values = list[3] as! [String?: Any?]

    return RtcStats(
      timestampUs: timestampUs,
      type: type,
      id: id,
      values: values
    )
  }
  func toList() -> [Any?] {
    return [
      timestampUs,
      type,
      id,
      values,
    ]
  }
}

/// A collection of reported statistics gathered about a WebRTC peer connection.
///
/// Generated class from Pigeon that represents data sent in messages.
struct RtcStatsReport {
  /// Timestamp at which the stats were gathered (in microseconds).
  var timestampUs: Double
  /// Map from object name to the stats associated with it.
  var stats: [String?: RtcStats?]

  static func fromList(_ list: [Any?]) -> RtcStatsReport? {
    let timestampUs = list[0] as! Double
    let stats = list[1] as! [String?: RtcStats?]

    return RtcStatsReport(
      timestampUs: timestampUs,
      stats: stats
    )
  }
  func toList() -> [Any?] {
    return [
      timestampUs,
      stats,
    ]
  }
}

private class RtcPeerConnectionHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return RtcIceCandidate.fromList(self.readValue() as! [Any?])
      case 129:
        return RtcSessionDescription.fromList(self.readValue() as! [Any?])
      case 130:
        return RtcStats.fromList(self.readValue() as! [Any?])
      case 131:
        return RtcStatsReport.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class RtcPeerConnectionHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? RtcIceCandidate {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? RtcSessionDescription {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? RtcStats {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? RtcStatsReport {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class RtcPeerConnectionHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return RtcPeerConnectionHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return RtcPeerConnectionHostApiCodecWriter(data: data)
  }
}

class RtcPeerConnectionHostApiCodec: FlutterStandardMessageCodec {
  static let shared = RtcPeerConnectionHostApiCodec(readerWriter: RtcPeerConnectionHostApiCodecReaderWriter())
}

/// API that receives messages about RtcPeerConnection instances in the host language.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol RtcPeerConnectionHostApi {
  /// Set the field trial keys and values enabled for future PeerConnections.
  func setFieldTrials(fieldTrials: [String: String]?) throws
  /// Create a PeerConnection.
  /// Returns an ID which can be used to refer to the native object in future calls.
  func create() throws -> Int64
  /// Dispose of the PeerConnection with the given [connectionId].
  func dispose(connectionId: Int64) throws
  /// Set the [description] of the remote peer for the PeerConnection with the given [connectionId].
  func setRemoteDescription(connectionId: Int64, description: RtcSessionDescription, completion: @escaping (Result<Void, Error>) -> Void)
  /// Set the [description] of the local peer for the PeerConnection with the given [connectionId].
  func setLocalDescription(connectionId: Int64, description: RtcSessionDescription, completion: @escaping (Result<Void, Error>) -> Void)
  /// Add an ICE [candidate] for connecting to the remote peer.
  func addRemoteCandidate(connectionId: Int64, candidate: RtcIceCandidate, completion: @escaping (Result<Void, Error>) -> Void)
  /// Create an answer to a WebRTC offer for the PeerConnection with the given [connectionId].
  func createAnswer(connectionId: Int64, completion: @escaping (Result<RtcSessionDescription, Error>) -> Void)
  /// Generate a stats report about the PeerConnection with the given [connectionId].
  /// If [typeFilter] is provided, the report will only contain stats matching types in that list, reducing the codec
  /// overhead from the native platform.
  func getStats(connectionId: Int64, typeFilter: [String]?, completion: @escaping (Result<RtcStatsReport, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class RtcPeerConnectionHostApiSetup {
  /// The codec used by RtcPeerConnectionHostApi.
  static var codec: FlutterStandardMessageCodec { RtcPeerConnectionHostApiCodec.shared }
  /// Sets up an instance of `RtcPeerConnectionHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: RtcPeerConnectionHostApi?) {
    /// Set the field trial keys and values enabled for future PeerConnections.
    let setFieldTrialsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionHostApi.setFieldTrials", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFieldTrialsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let fieldTrialsArg: [String: String]? = nilOrValue(args[0])
        do {
          try api.setFieldTrials(fieldTrials: fieldTrialsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setFieldTrialsChannel.setMessageHandler(nil)
    }
    /// Create a PeerConnection.
    /// Returns an ID which can be used to refer to the native object in future calls.
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionHostApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { _, reply in
        do {
          let result = try api.create()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    /// Dispose of the PeerConnection with the given [connectionId].
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionHostApi.dispose", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let connectionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.dispose(connectionId: connectionIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    /// Set the [description] of the remote peer for the PeerConnection with the given [connectionId].
    let setRemoteDescriptionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionHostApi.setRemoteDescription", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setRemoteDescriptionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let connectionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let descriptionArg = args[1] as! RtcSessionDescription
        api.setRemoteDescription(connectionId: connectionIdArg, description: descriptionArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setRemoteDescriptionChannel.setMessageHandler(nil)
    }
    /// Set the [description] of the local peer for the PeerConnection with the given [connectionId].
    let setLocalDescriptionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionHostApi.setLocalDescription", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLocalDescriptionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let connectionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let descriptionArg = args[1] as! RtcSessionDescription
        api.setLocalDescription(connectionId: connectionIdArg, description: descriptionArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setLocalDescriptionChannel.setMessageHandler(nil)
    }
    /// Add an ICE [candidate] for connecting to the remote peer.
    let addRemoteCandidateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionHostApi.addRemoteCandidate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addRemoteCandidateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let connectionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let candidateArg = args[1] as! RtcIceCandidate
        api.addRemoteCandidate(connectionId: connectionIdArg, candidate: candidateArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      addRemoteCandidateChannel.setMessageHandler(nil)
    }
    /// Create an answer to a WebRTC offer for the PeerConnection with the given [connectionId].
    let createAnswerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionHostApi.createAnswer", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createAnswerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let connectionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        api.createAnswer(connectionId: connectionIdArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      createAnswerChannel.setMessageHandler(nil)
    }
    /// Generate a stats report about the PeerConnection with the given [connectionId].
    /// If [typeFilter] is provided, the report will only contain stats matching types in that list, reducing the codec
    /// overhead from the native platform.
    let getStatsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionHostApi.getStats", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStatsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let connectionIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let typeFilterArg: [String]? = nilOrValue(args[1])
        api.getStats(connectionId: connectionIdArg, typeFilter: typeFilterArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getStatsChannel.setMessageHandler(nil)
    }
  }
}
private class RtcPeerConnectionFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return RtcIceCandidate.fromList(self.readValue() as! [Any?])
      case 129:
        return RtcTrackEvent.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class RtcPeerConnectionFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? RtcIceCandidate {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? RtcTrackEvent {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class RtcPeerConnectionFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return RtcPeerConnectionFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return RtcPeerConnectionFlutterApiCodecWriter(data: data)
  }
}

class RtcPeerConnectionFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = RtcPeerConnectionFlutterApiCodec(readerWriter: RtcPeerConnectionFlutterApiCodecReaderWriter())
}

/// API that receives messages about RtcPeerConnection instances in Flutter.
///
/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class RtcPeerConnectionFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return RtcPeerConnectionFlutterApiCodec.shared
  }
  /// Called when a new local ICE [candidate] is found for the PeerConnection with the given [connectionId].
  func onIceCandidate(connectionId connectionIdArg: Int64, candidate candidateArg: RtcIceCandidate?, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionFlutterApi.onIceCandidate", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([connectionIdArg, candidateArg] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when the [state] of the PeerConnection with the given [connectionId] changes.
  func onStateChanged(connectionId connectionIdArg: Int64, state stateArg: RtcPeerConnectionState, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionFlutterApi.onStateChanged", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([connectionIdArg, stateArg.rawValue] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when a MediaStreamTrack (described in [event]) is added to the PeerConnection with the given
  /// [connectionId].
  func onTrack(connectionId connectionIdArg: Int64, event eventArg: RtcTrackEvent, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionFlutterApi.onTrack", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([connectionIdArg, eventArg] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when a DataChannel with the given [dataChannelId] is added to the PeerConnection with the given
  /// [connectionId].
  func onDataChannel(connectionId connectionIdArg: Int64, dataChannelId dataChannelIdArg: Int64, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcPeerConnectionFlutterApi.onDataChannel", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([connectionIdArg, dataChannelIdArg] as [Any?]) { _ in
      completion()
    }
  }
}
private class RtcDataChannelHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return RtcDataBuffer.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class RtcDataChannelHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? RtcDataBuffer {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class RtcDataChannelHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return RtcDataChannelHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return RtcDataChannelHostApiCodecWriter(data: data)
  }
}

class RtcDataChannelHostApiCodec: FlutterStandardMessageCodec {
  static let shared = RtcDataChannelHostApiCodec(readerWriter: RtcDataChannelHostApiCodecReaderWriter())
}

/// API that receives messages about RtcDataChannel instances in the host language.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol RtcDataChannelHostApi {
  /// Send a message contained in [buffer] on the data channel with the given [dataChannelId].
  func sendMessage(dataChannelId: Int64, buffer: RtcDataBuffer) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class RtcDataChannelHostApiSetup {
  /// The codec used by RtcDataChannelHostApi.
  static var codec: FlutterStandardMessageCodec { RtcDataChannelHostApiCodec.shared }
  /// Sets up an instance of `RtcDataChannelHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: RtcDataChannelHostApi?) {
    /// Send a message contained in [buffer] on the data channel with the given [dataChannelId].
    let sendMessageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcDataChannelHostApi.sendMessage", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      sendMessageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let dataChannelIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let bufferArg = args[1] as! RtcDataBuffer
        do {
          try api.sendMessage(dataChannelId: dataChannelIdArg, buffer: bufferArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      sendMessageChannel.setMessageHandler(nil)
    }
  }
}
private class RtcDataChannelFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return RtcDataBuffer.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class RtcDataChannelFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? RtcDataBuffer {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class RtcDataChannelFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return RtcDataChannelFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return RtcDataChannelFlutterApiCodecWriter(data: data)
  }
}

class RtcDataChannelFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = RtcDataChannelFlutterApiCodec(readerWriter: RtcDataChannelFlutterApiCodecReaderWriter())
}

/// API that receives messages about RtcDataChannel instances in Flutter.
///
/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class RtcDataChannelFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return RtcDataChannelFlutterApiCodec.shared
  }
  /// Called when the [state] of the DataChannel with the given [dataChannelId] changes.
  func onStateChanged(dataChannelId dataChannelIdArg: Int64, state stateArg: RtcDataChannelState, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcDataChannelFlutterApi.onStateChanged", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([dataChannelIdArg, stateArg.rawValue] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when a message contained in [buffer] is received on the data channel with the given [dataChannelId].
  func onMessage(dataChannelId dataChannelIdArg: Int64, buffer bufferArg: RtcDataBuffer, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcDataChannelFlutterApi.onMessage", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([dataChannelIdArg, bufferArg] as [Any?]) { _ in
      completion()
    }
  }
}
/// API that receives messages about VideoViewController instances in the host language.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol RtcVideoViewControllerHostApi {
  /// Create a VideoViewController.
  /// Returns an ID which can be used to refer to the native object in future calls.
  func create() throws -> Int64
  /// Set the video track of the VideoViewController with the given [controllerId] to the track with the given
  /// [trackId].
  func setTrack(controllerId: Int64, trackId: Int64) throws
  /// Dispose of the VideoViewController with the given [controllerId].
  func dispose(controllerId: Int64) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class RtcVideoViewControllerHostApiSetup {
  /// The codec used by RtcVideoViewControllerHostApi.
  /// Sets up an instance of `RtcVideoViewControllerHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: RtcVideoViewControllerHostApi?) {
    /// Create a VideoViewController.
    /// Returns an ID which can be used to refer to the native object in future calls.
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcVideoViewControllerHostApi.create", binaryMessenger: binaryMessenger)
    if let api = api {
      createChannel.setMessageHandler { _, reply in
        do {
          let result = try api.create()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    /// Set the video track of the VideoViewController with the given [controllerId] to the track with the given
    /// [trackId].
    let setTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcVideoViewControllerHostApi.setTrack", binaryMessenger: binaryMessenger)
    if let api = api {
      setTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let controllerIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let trackIdArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        do {
          try api.setTrack(controllerId: controllerIdArg, trackId: trackIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTrackChannel.setMessageHandler(nil)
    }
    /// Dispose of the VideoViewController with the given [controllerId].
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcVideoViewControllerHostApi.dispose", binaryMessenger: binaryMessenger)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let controllerIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.dispose(controllerId: controllerIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
  }
}
/// API that receives messages about VideoViewController instances in Flutter.
///
/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class RtcVideoViewControllerFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  /// Called when the size of a VideoViewController's frame size changes.
  func onFrameSizeChanged(controllerId controllerIdArg: Int64, width widthArg: Int64, height heightArg: Int64, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.live_link_vcam.RtcVideoViewControllerFlutterApi.onFrameSizeChanged", binaryMessenger: binaryMessenger)
    channel.sendMessage([controllerIdArg, widthArg, heightArg] as [Any?]) { _ in
      completion()
    }
  }
}
